package securityscanutils

import (
	"bytes"
	"context"
	"encoding/gob"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	"github.com/Masterminds/semver/v3"
	"github.com/google/go-github/v32/github"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/githubutils"
	"github.com/spf13/cobra"
)

type options struct {
	ctx context.Context
	// Values that are empty/nil if unset
	targetRepo             string
	targetRepoWritten      string
	repoCachedReleasesFile string
	minScannedVersion      string
	imageFile              string
	// Values with defaults
	repoOwner                   string
	imageRepo                   string
	uploadCodeScanToGithub      bool
	createGithubIssuePerVersion bool
	generateCachedReleases      bool
	// Derived values that aren't directly related to inputs
	allImages []string
}

var (
	MissingGithubTokenError = func(envVar string) error {
		return eris.Errorf("Must either set GITHUB_TOKEN or set %s environment variable to true", envVar)
	}
	FileNotFoundError = func(path string, branch string) error {
		return eris.Errorf("Could not find file at path %s on branch %s", path, branch)
	}
	MalformedVersionImageConstraintLine = func(line string) error {
		return eris.Errorf("Could not properly split version image constraint line: %s", line)
	}
)

// Configure the CLI, including possible commands and input args.
func RootApp(ctx context.Context) *cobra.Command {
	opts := &options{
		ctx: ctx,
	}
	app := &cobra.Command{}
	// add commands
	app.AddCommand(securityScanMdFromCmd(opts))
	app.AddCommand(getReleasesCmd(opts))
	app.AddCommand(runSecurityScanCmd(opts))
	app.AddCommand(testArgs(opts))

	// add args/flags
	app.PersistentFlags().StringVarP(&opts.targetRepo, "TargetRepo", "r", "", "The repository to scan")
	app.PersistentFlags().StringVarP(&opts.targetRepoWritten, "TargetRepoWritten", "w", "",
		"Specify the human readable name of the repository to scan for output purposes.")
	app.PersistentFlags().StringVarP(&opts.repoCachedReleasesFile, "CachedReleasesFile", "c", "",
		"The name of the file that contains a list of all releases from the given repository."+
			" This file is generated by the 'gen-releases' command, and used by the others.")
	app.PersistentFlags().StringVarP(&opts.minScannedVersion, "MinScannedVersion", "m", "",
		"The minimum version of images to scan. If set, will scan every image from this to the present, and will scan all images otherwise")
	app.PersistentFlags().BoolVarP(&opts.uploadCodeScanToGithub, "UploadToGithub", "u", false,
		"Setting this to true will upload any generated sarif files to the github repository endpoint, "+
			"\ne.g. https://github.com/solo-io/gloo/security/code-scanning"+
			"\nread more here: https://docs.github.com/en/rest/reference/code-scanning."+
			"\nDefaults to false.")
	app.PersistentFlags().BoolVarP(&opts.createGithubIssuePerVersion, "CreateIssues", "i", true,
		"If true, open/update a Github Issue for each version that has images that have vulnerabilities. Defaults to true.")
	app.PersistentFlags().BoolVarP(&opts.generateCachedReleases, "GenerateCachedReleases", "p", true,
		"If true, then populate the file specified by the CachedReleasesFile flag with all releases from Github."+
			" If false, then the command assumes that the file has already been created and populated. "+
			" Should be set to false for testing to avoid rate-limiting by Github. Defaults to true.")
	app.PersistentFlags().StringVarP(&opts.imageFile, "ImageFile", "f", "",
		"Different release versions may have different images to scan."+
			"\nTo deal with this, the run-security-scan command expects a file input that maps version constraints to images"+
			"\nto be scanned if a version matches that constraint. Constraints must be mutually exclusive."+
			"\nThe file is expected to be a csv, where the first element of each line is the constraint, and every subsequent element"+
			"\nin that line is an image to be scanned if that constraint is matched."+
			"\nRead https://github.com/Masterminds/semver#checking-version-constraints for more about how to use semver constraints.")
	app.PersistentFlags().StringVarP(&opts.repoOwner, "RepoOwner", "", "solo-io",
		"The owner of the repository to scan. Defaults to 'solo-io'")
	app.PersistentFlags().StringVarP(&opts.imageRepo, "ImageRepo", "", "quay.io/solo-io",
		"The repository where images to scan are located. Defaults to 'quay.io/solo-io'")
	// mark required args

	_ = app.MarkFlagRequired("TargetRepo")
	_ = app.MarkFlagRequired("TargetRepoWritten")
	_ = app.MarkFlagRequired("ImageFile")

	return app
}

// Test command for sanity checking inputs
func testArgs(opts *options) *cobra.Command {
	app := &cobra.Command{
		Use:   "echo-inputs",
		Short: "Prints out all the state of all inputs (including inputted, defaults, and derived) for debugging purposes",
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Println("printing inputs")
			fmt.Printf("Target repo: %s\n", opts.targetRepo)
			fmt.Printf("Target repo human readable: %s\n", opts.targetRepoWritten)
			fmt.Printf("Upload code scan to github? %t\n", opts.uploadCodeScanToGithub)
			fmt.Printf("Create Github Issue per Version? %t\n", opts.createGithubIssuePerVersion)
			fmt.Printf("Cached Release Filename: %s\n", opts.repoCachedReleasesFile)
			fmt.Printf("Image version constraints file: %s\n", opts.imageFile)
			fmt.Printf("Minimum Scanned Version: %s\n", opts.minScannedVersion)
			constraints, err := readImageVersionConstraintsFile(opts)
			if err != nil {
				fmt.Printf("Warning - couldn't parse image version constraints file: %s", err.Error())
			} else {
				fmt.Printf("Parsed constraints:\n")
				for k, v := range constraints {
					fmt.Printf("Constraint: %s, images: %v\n", k, v)
				}
				fmt.Printf("List of all images found: %v\n", opts.allImages)
			}
			return nil
		},
	}

	return app
}

// Serializes github repository release and prints serialized releases to stdout
// To be used for caching release data for changelog/security scan docsgen.
func getReleasesCmd(opts *options) *cobra.Command {
	app := &cobra.Command{
		Use: "gen-releases",
		Short: "cache github releases for inputted repository. This is its own command to protect against rate-limiting" +
			" by github by trying to pull releases too much.",
		RunE: fetchAndSerializeReleases(opts),
	}
	return app
}

// Pulls scan results from google cloud bucket during docs generation.
// Then generates a human-readable single page for all our security scan results.
func securityScanMdFromCmd(opts *options) *cobra.Command {
	app := &cobra.Command{
		Use:   "gen-security-scan-md",
		Short: "pull down security scan files from gcloud bucket and generate docs markdown file",
		RunE: func(cmd *cobra.Command, args []string) error {
			return generateSecurityScanForRepo(opts)
		},
	}
	return app
}

// Command for running the actual security scan on the images
// running this runs trivy on all images for versions greater than
// MIN_SCANNED_VERSION.
// Uploads scanning results to github security tab and google cloud bucket.
func runSecurityScanCmd(opts *options) *cobra.Command {

	app := &cobra.Command{
		Use:   "run-security-scan",
		Short: "runs trivy scans on images from repo specified",
		Long:  "runs trivy vulnerability scans on images from the repo specified. Only reports HIGH and CRITICAL-level vulnerabilities and uploads scan results to google cloud bucket and github security page",
		RunE: func(cmd *cobra.Command, args []string) error {
			err := scanRepoImages(opts)
			return err
		},
	}
	return app
}

// Fetches releases and serializes them and prints to stdout.
// This is meant to be used so that releases can be cached locally for multiple tasks
// such as security scanning, changelog generation
// rather than fetch all repo releases per task and risk hitting GitHub ratelimit
func fetchAndSerializeReleases(opts *options) func(cmd *cobra.Command, args []string) error {
	return func(cmd *cobra.Command, args []string) error {
		if len(opts.repoCachedReleasesFile) == 0 {
			return eris.Errorf("Tried to generate cached releases, but an output file wasn't specified.")
		}
		if !opts.generateCachedReleases {
			return eris.Errorf("Ran command to generate cached releases, but the generateCachedReleases was set ot false")
		}
		client, err := githubutils.GetClient(opts.ctx)
		if err != nil {
			return err
		}

		err = getRepoReleases(opts.ctx, opts.targetRepo, client)
		return err
	}
}

// Serialized github RepositoryRelease array to be written to file
func getRepoReleases(ctx context.Context, repo string, client *github.Client) error {
	allReleases, err := githubutils.GetAllRepoReleases(ctx, client, "solo-io", repo)
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err = enc.Encode(allReleases)
	if err != nil {
		return err
	}
	fmt.Print(buf.String())
	return nil
}

func getCachedReleases(fileName string) []*github.RepositoryRelease {
	bArray, err := ioutil.ReadFile(fileName)
	if err != nil {
		return nil
	}
	buf := bytes.NewBuffer(bArray)
	enc := gob.NewDecoder(buf)
	var releases []*github.RepositoryRelease
	err = enc.Decode(&releases)
	if err != nil {
		return nil
	}
	return releases
}

func scanRepoImages(opts *options) error {
	var (
		stableOnlyConstraint *semver.Constraints
		err                  error
	)
	minVersionToScan := opts.minScannedVersion
	if minVersionToScan == "" {
		log.Println("MIN_SCANNED_VERSION input not set, scanning all versions from repo")
	} else {
		stableOnlyConstraint, err = semver.NewConstraint(fmt.Sprintf(">= %s", minVersionToScan))
		if err != nil {
			log.Fatalf("Invalid constraint version: %s", minVersionToScan)
		}
	}

	imagesPerVersion, err := readImageVersionConstraintsFile(opts)
	if err != nil {
		return err
	}

	scanner := &SecurityScanner{
		Repos: []*SecurityScanRepo{
			{
				Repo:  opts.targetRepo,
				Owner: "solo-io",
				Opts: &SecurityScanOpts{
					OutputDir:                   "_output/scans",
					ImagesPerVersion:            imagesPerVersion,
					VersionConstraint:           stableOnlyConstraint,
					ImageRepo:                   "quay.io/solo-io",
					UploadCodeScanToGithub:      opts.uploadCodeScanToGithub,
					CreateGithubIssuePerVersion: opts.createGithubIssuePerVersion,
				},
			},
		},
	}
	return scanner.GenerateSecurityScans(opts.ctx)
}

// Generates security scan log for releases
func generateSecurityScanForRepo(opts *options) error {
	// Initialize Auth
	client, err := githubutils.GetClient(opts.ctx)
	if err != nil {
		return err
	}
	var allReleases []*github.RepositoryRelease
	if len(opts.repoCachedReleasesFile) == 0 {
		allReleases = getCachedReleases(opts.repoCachedReleasesFile)
	} else {
		allReleases, err = githubutils.GetAllRepoReleases(opts.ctx, client, "solo-io", opts.targetRepo)
		if err != nil {
			return err
		}
	}
	githubutils.SortReleasesBySemver(allReleases)
	versionsToScan := getVersionsToScan(opts, allReleases)
	return BuildSecurityScanReportForRepo(versionsToScan, opts)
}

func getVersionsToScan(opts *options, releases []*github.RepositoryRelease) []string {
	var (
		versions             []string
		stableOnlyConstraint *semver.Constraints
		err                  error
	)
	minVersionToScan := opts.minScannedVersion
	if minVersionToScan == "" {
		log.Println("MinScannedVersion flag not set, scanning all versions from repo")
	} else {
		stableOnlyConstraint, err = semver.NewConstraint(fmt.Sprintf(">= %s", minVersionToScan))
		if err != nil {
			log.Fatalf("Invalid constraint version: %s", minVersionToScan)
		}
	}

	for _, release := range releases {
		// ignore beta releases when display security scan results
		test, err := semver.NewVersion(release.GetTagName())
		if err != nil {
			continue
		}
		if stableOnlyConstraint == nil || stableOnlyConstraint.Check(test) {
			versions = append(versions, test.String())
		}
	}
	return versions
}

func BuildSecurityScanReportForRepo(tags []string, opts *options) error {
	// tags are sorted by minor version
	latestTag := tags[0]
	prevMinorVersion, _ := semver.NewVersion(latestTag)
	for ix, tag := range tags {
		semver, err := semver.NewVersion(tag)
		if err != nil {
			return err
		}
		if ix == 0 || semver.Minor() != prevMinorVersion.Minor() {
			fmt.Printf("\n***Latest %d.%d.x %s Release: %s***\n\n", semver.Major(), semver.Minor(), opts.targetRepoWritten, tag)
			err = printImageReportForRepo(tag, opts)
			if err != nil {
				return err
			}
			prevMinorVersion = semver
		} else {
			fmt.Printf("<details><summary> Release %s </summary>\n\n", tag)
			err = printImageReportForRepo(tag, opts)
			if err != nil {
				return err
			}
			fmt.Println("</details>")
		}
	}

	return nil
}

func printImageReportForRepo(tag string, opts *options) error {
	for _, image := range opts.allImages {
		fmt.Printf("**%s %s image**\n\n", opts.targetRepoWritten, image)
		url := "https://storage.googleapis.com/solo-gloo-security-scans/" + opts.targetRepo + "/" + tag + "/" + image + "_cve_report.docgen"
		report, err := GetSecurityScanReport(url)
		if err != nil {
			return err
		}
		fmt.Printf("%s\n\n", report)
	}
	return nil
}

func GetSecurityScanReport(url string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}

	var report string
	if resp.StatusCode == http.StatusOK {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		report = string(bodyBytes)
	} else if resp.StatusCode == http.StatusNotFound {
		// Older releases may be missing scan results
		report = "No scan found\n"
	}
	resp.Body.Close()

	return report, nil
}

// Reads in a file, and tries to turn it into a map from version constraints to lists of images
// As a byproduct, it also caches all unique images found into the option field 'allImages'
// Also, I'm not sure why I didn't just use a csv reader... oh well.
func readImageVersionConstraintsFile(opts *options) (map[string][]string, error) {
	imagesPerVersion := make(map[string][]string)
	imageSet := make(map[string]interface{})

	dat, err := ioutil.ReadFile(opts.imageFile)
	if err != nil {
		return nil, err
	}
	for _, line := range strings.Split(string(dat), "\n") {
		trimmedLine := strings.TrimSpace(line)
		if len(trimmedLine) == 0 || string(trimmedLine[0]) == "#" {
			continue
		}
		values := strings.Split(trimmedLine, ",")
		if len(values) < 2 {
			return nil, MalformedVersionImageConstraintLine(line)
		}
		for i, _ := range values {
			trimVal := strings.TrimSpace(values[i])
			values[i] = trimVal
			if i > 0 {
				imageSet[trimVal] = nil
			}
		}
		imagesPerVersion[values[0]] = values[1:]
	}
	var allImages []string
	for image, _ := range imageSet {
		allImages = append(allImages, image)
	}
	opts.allImages = allImages

	return imagesPerVersion, nil
}
