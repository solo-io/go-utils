package hashutils

import (
	"encoding/binary"
	"hash"
	"hash/fnv"

	"github.com/mitchellh/hashstructure"
)

// Hashers are resources which have a custom hashing function defined.
// Hash functions are generated by default for go-utils resources
// Deprecated, use safe Hasher
type Hasher interface {
	Hash() uint64
}

// hash one or more values
// order matters
// Deprecated, use safe HashAllSafe
func HashAll(values ...interface{}) uint64 {
	var hashes []uint64
	for _, v := range values {
		hashes = append(hashes, hashValue(v))
	}
	return hashValue(hashes)
}

func hashValue(val interface{}) uint64 {
	if hasher, ok := val.(Hasher); ok {
		return hasher.Hash()
	}
	h, err := hashstructure.Hash(val, nil)
	if err != nil {
		panic("resource failed to hash: " + err.Error())
	}
	return h
}

type SafeHasher interface {
	Hash(hasher hash.Hash64) (uint64, error)
}

/*
	hash one or more values
	order matters

	This function returns the hashed result of all values passed into it.
	Any objects passed into it which fulfill the SafeHasher interface will be hashed this was,
	or using reflection if not. SafeHasher should be preferred. If no hasher is provided one will be provided.
	If a hasher is passed in, the returned hash can be ignored in favor of the hasher.
*/
func HashAllSafe(hasher hash.Hash64, values ...interface{}) (uint64, error) {
	if hasher == nil {
		hasher = fnv.New64()
	}
	for _, v := range values {
		if err := hashValueSafe(hasher, v); err != nil {
			return 0, nil
		}
	}
	return hasher.Sum64(), nil
}

func hashValueSafe(hasher hash.Hash64, val interface{}) error {
	if hashObj, ok := val.(SafeHasher); ok {
		_, err := hashObj.Hash(hasher)
		return err
	}
	h, err := hashstructure.Hash(val, nil)
	if err != nil {
		return err
	}
	return binary.Write(hasher, binary.LittleEndian, h)
}
