package hashutils

import (
	"encoding/binary"
	"hash"
	"hash/fnv"
	"log"

	"github.com/mitchellh/hashstructure"
)

//go:generate mockgen -destination mocks/hash_mocks.go  github.com/solo-io/go-utils/hashutils Hasher,SafeHasher

// Hashers are resources which have a custom hashing function defined.
// Hash functions are generated by default for go-utils resources
// Deprecated, use safe Hasher
type Hasher interface {
	Hash() uint64
}

// hash one or more values
// order matters
// Deprecated, use safe HashAllSafe
func HashAll(values ...interface{}) uint64 {
	var hashes []uint64
	for _, v := range values {
		hashes = append(hashes, hashValue(v))
	}
	return hashValue(hashes)
}

func hashValue(val interface{}) uint64 {
	if hasher, ok := val.(Hasher); ok {
		return hasher.Hash()
	}
	h, err := hashstructure.Hash(val, nil)
	if err != nil {
		panic("resource failed to hash: " + err.Error())
	}
	return h
}

type SafeHasher interface {
	Hash(hasher hash.Hash64) (uint64, error)
}

/*
	hash one or more values
	order matters

	This function returns the hashed result of all values passed into it.
	Any objects passed into it which fulfill the SafeHasher interface will be hashed this was,
	or using reflection if not. SafeHasher should be preferred. If no hasher is provided one will be provided.
	If a hasher is passed in, the returned hash can be ignored in favor of the hasher.
*/
func HashAllSafe(hasher hash.Hash64, values ...interface{}) (uint64, error) {
	if hasher == nil {
		hasher = fnv.New64()
	}
	for _, v := range values {
		if err := hashValueSafe(hasher, v); err != nil {
			return 0, nil
		}
	}
	return hasher.Sum64(), nil
}

func hashValueSafe(hasher hash.Hash64, val interface{}) error {
	if hashObj, ok := val.(SafeHasher); ok {
		_, err := hashObj.Hash(hasher)
		return err
	}
	h, err := hashstructure.Hash(val, nil)
	if err != nil {
		return err
	}
	return binary.Write(hasher, binary.LittleEndian, h)
}

/*
	This function takes in any number of resources and attempts to compare
	them as safe hashers.
	If any are not safe hashers it will return !ok. If they are all safe hashers,
	it will compare the equality of all of them
*/
func HashableEqual(val1 interface{}, val2 interface{}) (equal bool, ok bool) {
	val1Hasher, ok1 := interface{}(val1).(interface {
		Hash(hasher hash.Hash64) (uint64, error)
	})
	val2Hasher, ok2 := interface{}(val2).(interface {
		Hash(hasher hash.Hash64) (uint64, error)
	})
	if ok1 && ok2 {
		hash1, _ := val1Hasher.Hash(nil)
		hash2, _ := val2Hasher.Hash(nil)
		return hash1 == hash2, true
	}
	return false, false
}

/*
	This function will hash anything, and panic if it fails.
	If the object is a `SafeHasher` than it will use the generated Hasher, otherwise
	it will use the hashstructure library.
*/
func MustHash(val interface{}) uint64 {
	hasher, ok := interface{}(val).(interface {
		Hash(hasher hash.Hash64) (uint64, error)
	})
	if !ok {
		hashVal, err := hashstructure.Hash(val, nil)
		if err != nil {
			log.Panicf("hash err (%s) this should never happen", err)
		}
		return hashVal
	}
	hashVal, err := hasher.Hash(nil)
	if err != nil {
		log.Panicf("hash err (%s) this should never happen", err)
	}
	return hashVal
}
